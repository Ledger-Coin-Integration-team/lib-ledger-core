- RFC name: `0003-modularized-react-native-packaging`.
- Status: `draft`.
- Author: [Dimitri Sabadie](https://github.com/phaazon)
- Date Created: 2020/04/21
- Date Updated: 2020/04/21
- Summary: **N:1 React Native packaging of the modularized core (N coins, 1 React Native package).**

<!-- vim-markdown-toc GFM -->

* [Motivation](#motivation)
* [Content](#content)
  * [How packaging is done on the legacy path (analysis)](#how-packaging-is-done-on-the-legacy-path-analysis)
  * [How packaging is done on the modularized path](#how-packaging-is-done-on-the-modularized-path)

<!-- vim-markdown-toc -->

# Motivation
> Why such a PoC?

This is the second part of the “Ledger Live” PoC integration. After having added support for the
Node.js (Desktop) support, it was just a matter of time before starting the support of the mobile
part, which uses React Native.

The difficulty here lies in the fact that we need to configure and port two projects: the React
Native Android part, and the React Native iOS part. Because that, at the time of writing this very
document, the world is going through the Covid-19 pandemic, and the author of this RFC and
implementation (Dimitri Sabadie) doesn’t have access to a macOS system, Android will be the first
candidate for a port. However, besides some very specific implementation details for each platform,
the code between Android and iOS should remain the same, at least for the Ledger Live team.

# Content
> Content of the PoC with comments and step-by-step procedure.

## How packaging is done on the legacy path (analysis)

The script `tools/generateBindingsRN.sh` generates all the code for React Native, Java (Android),
Obj-C and Obj-C++ (iOS) inside the binding destination (typically,
`../lib-ledger-core-react-native-bindings`).

Android libraries go into the `android/libs` folder, and the iOS libraries into
the `ios/Frameworks` folder.

Then, each project is configured via different files regarding the platform:

- Android is configured via the file `android/build.gradle`.
- iOS is configured via the XCode projects found in `ios`.

From now on, we focus on Android. The `build.gradle` file contains folders only, even for the
libraries to use. So the Core libraries (i.e. `libledger-core.so`) are picked automatically
from that folder (`jniLibs.srcDirs = ['libs']`).

The `android/src` directory contains the source used to build the ReactNative library for Android.
`android/src/main/java` contains all the source files and `android/src/main/AndroidManifest.xml`
is a file containing the basic React Native manifest file. That file doesn’t contain much and
shouldn’t change that much.

Then, in `android/src/main/java`, we have `co/ledger` and `com/ledger`. The difference between those
two folders is that the `com/ledger/reactnative` folder contains all React Native (RCT types)
as well as the implementations required to be present for the Core interface (such as HTTP
clients, random number generators, etc.). `co/ledger/core` contains generated code for Java
from the Core generation process, which implies `djinni`.

Most of the work will be performed by the Android toolchain (Android Studio / whatever you are
using).

## How packaging is done on the modularized path

As we did with the [node packaging RFC](./0002-modularized-node-packaging.md), we need to use the
bundled version of the library and the `bundle.djinni` file to generate the whole React Native
binding code. `lc pkg rn` generates the whole project by making calls to `djinni` with
`bundle.djinni` as main file.

The technical part is that because mobile projects might target several platforms, the core
library must be generated for all of them. If you are testing on a specific device, you don’t have
to generate all possible libraries: just generate the one you’re interested in. As with the node
packaging, the syntax is expected to be:

```
${BUILD}_${PLATFORM}
```

Where `${BUILD}` is `build` by default and can be overridden and `${PLATFORM}` is one of:

- `x86` for 32-bit CPU architecture.
- `x86_64` for 64-bit CPU architecture.
- `armeabi_v7a` for v7a ARM CPU architecture.
- `arm64_v8a` for v8a ARM CPU architecture.

That directory is expected to be present when packaging for the target platform. The library should
be generated by using the right CMake toolchain. You can find them by setting the right environment
variable and compile with the right flag. For instance, to compile an `arm64_v8a` version of the
Core library:

```
mkdir build_arm64_v8a
cd build_arm64_v8a
export POLLY_ROOT=../toolchains/polly
export ANDROID_NDK_r16b=~/android_ndk_16b # use your path
export JAVA_HOME="$(/usr/libexec/java_home -v 1.8)"
export TOOLCHAIN_NAME='android-ndk-r16b-api-21-arm64-v8a-neon-clang-libcxx14'
cmake .. \
  -DBUILD_TESTS=OFF \
  -DSYS_OPENSSL=ON \
  -DOPENSSL_ROOT_DIR=~/github/openssl \ # required on some Linux distribution (Archlinux)
  -DCMAKE_BUILD_TYPE=Debug \ # useful to debug the application if needed
  -DBUILD_COINS="bitcoin,ethereum,ripple,tezos" \
  -DTARGET_JNI=ON \
  -DCMAKE_TOOLCHAIN_FILE=${POLLY_ROOT}/${TOOLCHAIN_NAME}.cmake




# Rationale.
> Should we go for it? Drop it?

# Related work
> What else has been done and is similar?

```
ANDROID_NDK_r16b=~/Android/Sdk/ndk/16.1.4479499 cmake .. -DCMAKE_INSTALL_PREFIX=/tmp/js-core-install -DCMAKE_BUILD_TYPE=Debug -DBUILD_TESTS=OFF -DTARGET_JNI=ON -DCMAKE_TOOLCHAIN_FILE=../../toolchains/polly/android-ndk-r16b-api-21-arm64-v8a-neon-clang-libcxx14.cmake
```
